{"version":3,"sources":["webpack://Wedding/webpack/universalModuleDefinition","webpack://Wedding/webpack/bootstrap","webpack://Wedding/./src/emitter.js","webpack://Wedding/./src/helpers.js","webpack://Wedding/./src/events.js","webpack://Wedding/./src/index.js","webpack://Wedding/./main.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","emitter","events","create","on","fn","_extends2","this","console","error","_extends","emit","isConnecter","frame","contentWindow","postMessage","url","parent","off","_extends3","undefined","validateConstructor","whitelist","checkConnecter","length","checkWhitelist","statuses","disconnected","connecting","connected","startConnection","finishConnection","clearInterval","connectionInterval","status","info","src","Wedding","_ref","src_classCallCheck","_this","_possibleConstructorReturn","_Emitter","src_extends","self","addEventListener","e","includes","origin","data","createConnectionListener","connect","_this2","document","createElement","helpers_extends","style","display","body","append","setInterval","__webpack_exports__","arguments","_ref$isConnecter","_ref$url","_ref$whitelist"],"mappings":"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","file":"wedding.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Wedding\"] = factory();\n\telse\n\t\troot[\"Wedding\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","class Emitter {\n  constructor() {\n    this.events = Object.create(null);\n  }\n\n  on(name, fn) {\n    if (this.events[name]) {\n      console.error('This event listner already exists');\n      return;\n    }\n\n    this.events = Object.assign(this.events, { [name]: fn });\n  }\n\n  emit(name) {\n    if (this.isConnecter) {\n      this.frame.contentWindow.postMessage(name, this.url);\n    } else {\n      window.parent.postMessage(name, this.url);\n    }\n  }\n\n  off(name) {\n    if (!this.events[name]) {\n      console.error('This event listner doesnt exists');\n      return;\n    }\n\n    this.events = Object.assign({}, { [name]: undefined });\n  }\n}\n\nexport default Emitter;\n","// Create connection function\n// creates iFrame and trying to connect inside with interval\nexport function createConnection(url) {\n  const frame = document.createElement('iframe');\n\n  Object.assign(frame, {\n    name: 'theFionce',\n    src: url,\n    style: {\n      display: 'none',\n    },\n  });\n\n  document.body.append(frame);\n  return frame;\n}\n\n// Create connection listner on window\nexport function createConnectionListener(whitelist, self) {\n  window.addEventListener('message', (e) => {\n    if (!whitelist.includes(e.origin)) {\n      console.error('Origin is not included in whitelist');\n      return;\n    }\n\n    self.events[e.data]();\n  }, false);\n}\n\n// Validations\nfunction checkConnecter(isConnecter, url) {\n  if (isConnecter && url === '') {\n    console.error('Please provide correct url for connections');\n    return false;\n  }\n\n  return true;\n}\n\nfunction checkWhitelist(whitelist) {\n  if (whitelist.length === 0) {\n    console.error('Please provide whitelist for connections');\n    return false;\n  }\n\n  return true;\n}\n\nexport function validateConstructor(isConnecter, url, whitelist) {\n  return checkConnecter(isConnecter, url) && checkWhitelist(whitelist);\n}\n\nexport const statuses = {\n  disconnected: 'disconnected',\n  connecting: 'connecting',\n  connected: 'connected',\n};\n","import { statuses } from './helpers';\n\n// Default events\nfunction startConnection() {\n  this.emit('connection:finished');\n}\n\nfunction finishConnection() {\n  clearInterval(this.connectionInterval);\n  this.status = statuses.connected;\n\n  console.info('Connection established');\n}\n\n// exported function\nexport default function initEvents() {\n  this.on('connection:start', startConnection);\n  this.on('connection:finished', finishConnection);\n}\n","import Emitter from './emitter';\nimport initEvents from './events';\nimport { createConnection, createConnectionListener, statuses } from './helpers';\n\nclass Wedding extends Emitter {\n  constructor({ isConnecter, url, whitelist }) {\n    super();\n\n    Object.assign(this, {\n      isConnecter,\n      url,\n      whitelist,\n      frame: null,\n      connectionInterval: null,\n      status: statuses.disconnected,\n    });\n\n    createConnectionListener(this.whitelist);\n    initEvents.call(this);\n  }\n\n  connect() {\n    if (this.isConnecter) {\n      console.info('Initializing connection');\n      this.frame = createConnection(this.url);\n\n      this.connectionInterval = setInterval(() => {\n        this.emit('connection:start');\n      }, 1000);\n\n      this.status = statuses.connecting;\n    } else {\n      console.error('This is not a connector');\n    }\n  }\n}\n\nexport default Wedding;\n","import WeddingConstructor from './src/index';\nimport { validateConstructor } from './src/helpers';\n\nconst Wedding = ({\n  isConnecter = false,\n  url = '',\n  whitelist = [],\n} = {}) => {\n  // Validate before construct\n  if (!validateConstructor(isConnecter, url, whitelist)) {\n    return null;\n  }\n\n  return new WeddingConstructor({ isConnecter, url, whitelist });\n};\n\nexport default Wedding;\n"],"sourceRoot":""}
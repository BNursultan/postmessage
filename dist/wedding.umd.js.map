{"version":3,"sources":["webpack://Wedding/webpack/universalModuleDefinition","webpack://Wedding/webpack/bootstrap","webpack://Wedding/./main.js","webpack://Wedding/./src/emitter.js","webpack://Wedding/./src/events.js","webpack://Wedding/./src/helpers.js","webpack://Wedding/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_ref","arguments","length","undefined","_ref$isConnecter","isConnecter","_ref$url","url","_ref$whitelist","whitelist","_src_helpers__WEBPACK_IMPORTED_MODULE_1__","_src_index__WEBPACK_IMPORTED_MODULE_0__","Emitter","_classCallCheck","this","events","create","on","fn","_extends2","console","error","_extends","emit","frame","contentWindow","postMessage","parent","off","_extends3","startConnection","finishConnection","clearInterval","connectionInterval","status","_helpers__WEBPACK_IMPORTED_MODULE_0__","connected","info","initEvents","createConnection","document","createElement","src","style","display","body","append","createConnectionListener","self","addEventListener","e","includes","origin","data","validateConstructor","checkConnecter","checkWhitelist","statuses","disconnected","connecting","Wedding","_this","_possibleConstructorReturn","_Emitter","_helpers__WEBPACK_IMPORTED_MODULE_2__","_events__WEBPACK_IMPORTED_MODULE_1__","connect","_this2","setInterval","_emitter__WEBPACK_IMPORTED_MODULE_0__"],"mappings":"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","file":"wedding.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Wedding\"] = factory();\n\telse\n\t\troot[\"Wedding\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./main.js\");\n","import WeddingConstructor from './src/index';\nimport { validateConstructor } from './src/helpers';\n\nconst Wedding = ({\n  isConnecter = false,\n  url = '',\n  whitelist = [],\n} = {}) => {\n  // Validate before construct\n  if (!validateConstructor(isConnecter, url, whitelist)) {\n    return null;\n  }\n\n  return new WeddingConstructor({ isConnecter, url, whitelist });\n};\n\nexport default Wedding;\n","class Emitter {\n  constructor() {\n    this.events = Object.create(null);\n  }\n\n  on(name, fn) {\n    if (this.events[name]) {\n      console.error('This event listner already exists');\n      return;\n    }\n\n    this.events = Object.assign(this.events, { [name]: fn });\n  }\n\n  emit(name) {\n    if (this.isConnecter) {\n      this.frame.contentWindow.postMessage(name, this.url);\n    } else {\n      window.parent.postMessage(name, this.url);\n    }\n  }\n\n  off(name) {\n    if (!this.events[name]) {\n      console.error('This event listner doesnt exists');\n      return;\n    }\n\n    this.events = Object.assign({}, { [name]: undefined });\n  }\n}\n\nexport default Emitter;\n","import { statuses } from './helpers';\n\n// Default events\nfunction startConnection() {\n  this.emit('connection:finished');\n}\n\nfunction finishConnection() {\n  clearInterval(this.connectionInterval);\n  this.status = statuses.connected;\n\n  console.info('Connection established');\n}\n\n// exported function\nexport default function initEvents() {\n  this.on('connection:start', startConnection);\n  this.on('connection:finished', finishConnection);\n}\n","// Create connection function\n// creates iFrame and trying to connect inside with interval\nexport function createConnection(url) {\n  const frame = document.createElement('iframe');\n\n  Object.assign(frame, {\n    name: 'theFionce',\n    src: url,\n    style: {\n      display: 'none',\n    },\n  });\n\n  document.body.append(frame);\n  return frame;\n}\n\n// Create connection listner on window\nexport function createConnectionListener(whitelist, self) {\n  window.addEventListener('message', (e) => {\n    if (!whitelist.includes(e.origin)) {\n      console.error('Origin is not included in whitelist');\n      return;\n    }\n\n    self.events[e.data]();\n  }, false);\n}\n\n// Validations\nfunction checkConnecter(isConnecter, url) {\n  if (isConnecter && url === '') {\n    console.error('Please provide correct url for connections');\n    return false;\n  }\n\n  return true;\n}\n\nfunction checkWhitelist(whitelist) {\n  if (whitelist.length === 0) {\n    console.error('Please provide whitelist for connections');\n    return false;\n  }\n\n  return true;\n}\n\nexport function validateConstructor(isConnecter, url, whitelist) {\n  return checkConnecter(isConnecter, url) && checkWhitelist(whitelist);\n}\n\nexport const statuses = {\n  disconnected: 'disconnected',\n  connecting: 'connecting',\n  connected: 'connected',\n};\n","import Emitter from './emitter';\nimport initEvents from './events';\nimport { createConnection, createConnectionListener, statuses } from './helpers';\n\nclass Wedding extends Emitter {\n  constructor({ isConnecter, url, whitelist }) {\n    super();\n\n    Object.assign(this, {\n      isConnecter,\n      url,\n      whitelist,\n      frame: null,\n      connectionInterval: null,\n      status: statuses.disconnected,\n    });\n\n    createConnectionListener(this.whitelist);\n    initEvents.call(this);\n  }\n\n  connect() {\n    if (this.isConnecter) {\n      console.info('Initializing connection');\n      this.frame = createConnection(this.url);\n\n      this.connectionInterval = setInterval(() => {\n        this.emit('connection:start');\n      }, 1000);\n\n      this.status = statuses.connecting;\n    } else {\n      console.error('This is not a connector');\n    }\n  }\n}\n\nexport default Wedding;\n"],"sourceRoot":""}